---
title: 'cross-checking: numeric vs choices'
author: "Xinbin Huang"
date: "December 12, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

# Overview
 
## Load libraries

```{r}
library(tidyverse)
library(stringr)
```

## Load data
```{r}
numeric_df <- read_csv('../../TestCase/Canada_Block_TEST_NUMERICValues.csv')
choice_df <- read_csv('../../TestCase/Canada_Block_TEST_ChoiceValues.csv')

numeric_longVar <- numeric_df %>% slice(1:2)
choice_longVar <- choice_df %>% slice(1:2)

numeric_df <- numeric_df %>% slice(3:n())
choice_df <- choice_df %>% slice(3:n())

var_overview <- readxl::read_xlsx('../../QuestionnaireOverviews/VariableOverview_Dec2018.xlsx')
```

## Glimpse

`identical` vs `isTRUE(all_equal())`: `identical` is too strict for most of the cases. When working with `dplyr` verbs, the resulting data frame usually remove the `$spec` attribute (i.e. `attributes(df)`), and this will make identical false when all data entries are the same, (which are the things we care about at most of the time.).

```{r}
check_equal <- function(a, b) {
      return(assertthat::assert_that(all_equal(a, b)))
}

check_identical <- function(a, b){
      return(assertthat::assert_that(isTRUE(all_equal(a, b))))
}

check_sameCols <- function(a, b) {
      cols_a <- colnames(a)
      cols_b <- colnames(b)
      return(check_identical(cols_a, cols_b))
}

# check same columns
check_sameCols(numeric_df, choice_df)
```



```{r}
# Check idential response ID

check_responseID <- function(a, b) {
      ID_a <- a$ResponseId
      ID_b <- b$ResponseId
      return(check_identical(ID_a, ID_b))
}

check_responseID(numeric_df, choice_df)
```


## check each group of variables

get the `var_list`

```{r}
var_list <- jsonlite::fromJSON('../variables.json', 
                               simplifyVector = FALSE)

labels_list <- var_list %>% 
      map('labels') %>% 
      map(flatten_chr)

names <- var_list %>% 
      map_chr('name')

names(labels_list) <- names
```

define `check_vars` function

```{r}
check_vars <- function(a, b, vars) {
      vars_a <- a %>% select(vars)
      vars_b <- b %>% select(vars)
      tryCatch(check_identical(vars_a, vars_b), 
               error = function(e) {
                     e$message <- paste0(e$message, ". (", 
                                         all.equal(vars_a, vars_b),
                                         ").")
                     
                     parse_varname <- function(x) deparse(substitute(x)) 
                     
                     .last.error <<- list(
                           'msg' = e$message,
                           a_name = vars_a,
                           b_name = vars_b
                     )
                     
                     stop(e)
               })
}
```


1. generic questionaire variables 

Different: `status` and `Finished` columns are different.


```{r}
gen_vars <- colnames(numeric_df)[1:14]
print(gen_vars)

try(check_vars(numeric_df, choice_df, gen_vars))
.last.error[[2]] %>% slice(363) %>% 
      bind_rows(.last.error[[3]] %>% slice(363))
```


2. `Perceived Descritpive Norms about Childcare`

```{r}
vars <- labels_list$`Perceived Descritpive Norms about Childcare`

check_vars(numeric_df, choice_df, vars = vars)
```


3. `Perceived Descriptive Norms: HEED, STEM and Work`

```{r}
vars <- labels_list$`Perceived Descriptive Norms: HEED, STEM and Work`

check_vars(numeric_df, choice_df, vars = vars)
```

4. `Perceived injunctive Norms`

Something problem here need to be checked.

```{r}
vars <- labels_list$`Perceived injunctive Norms`

try(check_vars(numeric_df, choice_df, vars = vars))
```

Reason: For `Choice`, some variables, which are encoded as integers from 1 to 7, also include the text for edge values. (i.e. 1, 7)

Solution: extract only the integers.

```{r}
# reason: edge values also include text
.last.error[[2]] %>% slice(362) %>% 
bind_rows(.last.error[[3]] %>% slice(362))
```
```{r}
# solution: extract only numbers
extract_nums <- function(df) {
      extraction <- funs(str_extract(., "^[0-9]{1,3}"))
      output <- df %>% mutate_all(extraction)
      return(output)
            
}

convert_choiceDF <- function(df, vars) {
      output <- df %>% 
            select(vars) %>% 
            extract_nums()
      return(output)
}


converted_choice <- convert_choiceDF(choice_df, vars)

check_vars(numeric_df, converted_choice, vars = vars)

```

5. `Own Support for Equality`

```{r}
vars <- labels_list$`Own Support for Equality`

try(check_vars(numeric_df, choice_df, vars = vars))

converted_choice <- convert_choiceDF(choice_df, vars)

check_vars(numeric_df, converted_choice, vars = vars)
```

6. `Personal Evaluations`

```{r}
vars <- labels_list$`Personal Evaluations`

try(check_vars(numeric_df, choice_df, vars = vars))

converted_choice <- convert_choiceDF(choice_df, vars)

check_vars(numeric_df, converted_choice, vars = vars)
```


7. `Family Expectations`

There are some mismatching variables names between the variable list and the original collected data.

`parentleave_motivation` ==> `parentleave_motivati_1`
`parentleave_expectation` ==> `parentleave_expectat`
`expected_share_3` ==> `expected_share_12`

```{r}
vars <- labels_list$`Family Expectations`

mapping <- c('parentleave_motivation' = 'parentleave_motivati_1',
             'parentleave_expectation' = 'parentleave_expectat',
             'expected_share_3' = 'expected_share_12')

map_vars <- function(vars, mapping) {
      output <- vars %>% str_replace_all(mapping) 
      return(output)
}

vars <- map_vars(vars, mapping)

try(check_vars(numeric_df, choice_df, vars = vars))
```

Also, there are new problems need to inspect

```{r}
converted_choice <- convert_choiceDF(choice_df, vars)

check_vars(numeric_df, converted_choice, vars = vars)
```




